czyDzielenie(X):-
    X = '/'.

czyMno¿enie(X):-
    X = '*'.

isEmpty(L):- % sprawdzenie czy lista jest pusta
    length(L,S),
    S=:=0.

rozdzielMno¿enia(Dzia³anie,Elementy):-
    Dzia³anie=..[Operacja|L],
    czyMno¿enie(Operacja)->( % jeœli operacja jest mno¿eniem
               L=[Lewy,Prawy], % biorê mno¿n¹ i mno¿nik
               rozdzielMno¿enia(Lewy,Lelems), % dalej sprwadzam czy zawieraj¹ iloraz i dostajê tablicê mno¿nych i mno¿ników
               rozdzielMno¿enia(Prawy,Pelems),
               K=[Lelems,Pelems],  % scalam dwie tablice
               append([],K,Elementy), % dodajê do zmiennej elementy
               true
           )
    ; append([],Dzia³anie,Elementy).

po³¹czMno¿enia(Elementy, Dzia³anie):- % tworzenie ilorazu z elementów w Elementy i wpisanie go do Dzia³anie
    Elementy=[Element|Reszta], % biorê pierwszy element z listy
    length(Reszta,Len),
    Len =:= 0 ->(
                append([],Element,Dzia³anie),!
            )
    ;
    po³¹czMno¿enia(Reszta,Dzia³), % resztê dalej dzielê
    K=..[*,Element,Dzia³], % póŸniej rekurencyjne ³¹czenie znakiem *
    append([],K,Dzia³anie).

regu³a(X,O,Y,Y):- % sprawdzenie czy nie dodajê zera
    O = '+',
    X = 0, !.
regu³a(X,O,Y,0):- % sprawdzenie czy nie odejmujê takich samych elementów od siebie
    O = '-',
    X = Y.
regu³a(X,O,Y,0):- % sprawdzenie iloczynu lub ilorazu z udzia³em zera
    not(
        O = '+';
        O = '-'
    ),
    X = 0;
    Y = 0. % tu siê pozbywam operacji, które maj¹ dzielenie przez 0

regu³a(X,O,Y,S):- % regu³a skracaj¹ca u³amki
    czyDzielenie(O),
    rozdzielMno¿enia(X,Xelems), % zwraca tablicê elementów które mo¿na skróciæ z dzielnej
    (   ( \+ is_list(Xelems)) -> Xele=[Xelems] % jeœli zwróci³ jeden element to robiê z niego listê
    ;
    Xele=Xelems
   ),
    rozdzielMno¿enia(Y,Yelems), % zwraca tablicê elementów które mo¿na skróciæ z dzielnika
   (    (\+ is_list(Yelems)) -> Yele=[Yelems]
    ;
    Yele=Yelems
   ),
    intersection(Xele,Yele,Common), % znalezienie elemntów wspólnych z dzielnika i dzielnej
    length(Common,Len),
    (   Len =:= 0 ->( % jeœli nie ma wspólnych elementów to zwrócenie pierwotnego dzia³ania
                K=..[O,X,Y],
                append([],K,S),
                true
            )
    ;
        subtract(Xele,Common,Newx), % znalezienie elementów, które nie zostan¹ skrócone z dzielnej
        subtract(Yele,Common,Newy), % znalezienie elementów, które nie zostan¹ skrócone z dzielnika

        (isEmpty(Newx) -> Xdzia³=1; po³¹czMno¿enia(Newx,Xdzia³)), % jeœli s¹ jeszcze jakieœ elementy w dzielniku to ³¹czê je mno¿eniem
        (isEmpty(Newy) -> append([],Xdzia³,S); po³¹czMno¿enia(Newy,Ydzia³), % jeœli nie ma elementów w dzielnej to ona znika
        K=..[O,Xdzia³,Ydzia³],
        append([],K,S))
    )
    .

uproœæ(X,W):-
    setof(X, uproœæ_(X,W), Set),
    member(X,Set), !.

% rozdzielam na termy dopóki nie dostanê pojedyñczych symboli
uproœæ_(X,W):-
    append([],X,X),
    append([],X,W).
uproœæ_(X,W):-
    X =..[Operacja, Lewa, Prawa],
    uproœæ(Lewa, Lwynik),
    uproœæ(Prawa,Pwynik),
    (
         (
              \+ czyMno¿enie(Operacja),
              \+ czyDzielenie(Operacja),
              regu³a(Lwynik, Operacja, Pwynik, Pwynik)  % sprawdzam czy dodaje lub odejmuje 0
          ) ->
              (Pwynik = 0 -> append([],Lwynik,W); append([],Pwynik, W))
          ;  regu³a(Lwynik, Operacja, Pwynik, 0) -> append([],0,W) % sprawdzam czy wynik dwóch operacji da mi w rezultacie zero
          ;  regu³a(Lwynik,Operacja, Pwynik, S) -> append([],S,W)  % sprawdzam czy da siê coœ skóciæ w u³amku
          ;  K=..[Operacja, Lwynik, Pwynik], append([],K,W) % jeœli siê nic nie da zredukowaæ zwracam formê pocz¹tkow¹
          ).

